---
title: "Mix de Produ√ß√£o - Abordagem Concreta"
format: html
---

# Problema

(Belfiore e F√°vero) A empresa Venix de brinquedos est√° revendo seu planejamento de produ√ß√£o de carrinhos e triciclos:

-   O lucro l√≠quido por unidade de carrinho e triciclo produzido √© de R\$12 e R\$60, respectivamente.

-   As mat√©rias primas e os insumos necess√°rios para a fabrica√ß√£o de cada um dos produtos s√£o terceirizados, cabendo √† empresa os processos de usinagem, pintura e montagem.

-   O processo de usinagem requer 15 minutos de m√£o de obra especializada por unidade de carrinho e 30 minutos por unidade de triciclo produzida.

-   O processo de pintura requer 6 minutos de m√£o de obra especializada por unidade de carrinho e 45 minutos por unidade de triciclo produzida.

-   J√° o processo de montagem necessita de 6 minutos e 24 minutos para uma unidade de carrinho e de triciclo produzida, respectivamente.

-   O tempo dispon√≠vel por semana √© de 36, 22 e 15 horas para os processos de usinagem, pintura e montagem, respectivamente.

A empresa quer determinar quanto produzir de cada produto por semana, respeitando as limita√ß√µes de recursos, de forma a maximizar o lucro l√≠quido semanal. Formular o problema de programa√ß√£o linear que maximiza o lucro l√≠quido da empresa Venix.

## Resumo do lucro por produto:

|             | carrinho | triciclo |
|-------------|----------|----------|
| Lucro (R\$) | 12       | 60       |

## Convers√£o do problema para uma unidade padr√£o (horas):

| Processo | carrinho      | triciclo     | disponibildade |
|----------|---------------|--------------|----------------|
| Usinagem | 0,25h (15min) | 0,5h (30min) | 36h            |
| Pintura  | 0,1h (6min)   | 0,75h(45min) | 22h            |
| Montagem | 0,1h (6min)   | 0,4h (24min) | 15h            |

# Representa√ß√£o matricial

## Fun√ß√£o objetivo

$\max z = \mathbf{c}^T\mathbf{x}$

Maximizar o produto entre o vetor de lucros unit√°rios $\mathbf{c}$ e o vetor de quantidades a produzir $\mathbf{x}$ (produto escalar entre $\mathbf{c}^T$ e $\mathbf{x}^n$ )

O termo $\mathbf{c}^T\mathbf{x}$ √© a soma ponderada dos lucros, ou seja, nesse caso √© a mesma coisa que $12x_1 + 60x_2$. Essa seria a vis√£o matricial:

$\mathbf{c} =
\begin{bmatrix}
12 \\[4pt]
60
\end{bmatrix},
\quad
\mathbf{x} =
\begin{bmatrix}
x_1 \\[4pt]
x_2
\end{bmatrix}$

## Restri√ß√µes

### Restri√ß√£o 1:

$\mathbf{Ax} \leq \mathbf{b}$

O produto matricial $\mathbf{Ax}$ representa o consumo total de horas em cada processo (usinagem, pintura e montagem), calculado como a soma das horas necess√°rias por produto multiplicadas pelas quantidades produzidas.

Cada linha de $\mathbf{Ax} \leq \mathbf{b}$ garante que o tempo utilizado em cada processo n√£o excede a disponibilidade total de horas presente no vetor coluna de disponibilidades $\mathbf{b}$. A vis√£o matricial seria assim:\

$\mathbf{A} =
\begin{bmatrix}
0.25 & 0.50 \\[4pt]
0.10 & 0.75 \\[4pt]
0.10 & 0.40
\end{bmatrix},
\quad
\mathbf{b} =
\begin{bmatrix}
36 \\[4pt]
22 \\[4pt]
15
\end{bmatrix}$

### Restri√ß√£o 2:

$\mathbf{x} \geq \mathbf{0}$

O vetor X n√£o pode ser negativo. N√£o tem como produzir uma quantidade negativa de produtos.

# Representa√ß√£o Gen√©rica

## √çndices / Conjuntos:

$I \colon \{1, \ldots, m\}$

$I:$ Conjunto dos recursos ou processos produtivos (usinagem, puntura, montagem). Cada elemento $i \in I$ representa um tipo de recurso com disponibilidade limitada.

$J \colon \{1, \ldots n\}$

$J:$Conjunto dos produtos a serem fabricados (carrinhos e triciclos). Cada elementa $j \in J$ representa um produto que consome os recursos do conjunto $I$.

## Par√¢metros:

(tudo que j√° sabemos antes de resolver o problema)

$c_j \colon \text{lucro l√≠quido por unidade do produto } j \in J \text{ produzido}$

(Retorno financeiro de cada produto)

$a_{ij} \colon \text{quantidade de horas necess√°rias para a execu√ß√£o do processo } i \in I \text{ na fabrica√ß√£o do produto } j \in J$

(representa o consumo unit√°rio de cada recurso por produto)

$b_i \colon \text{quantidade de horas dispon√≠veis para execu√ß√£o do processo } i \in I$

(capacidade maxima dispon√≠vel do recurso $i$ )

## Vari√°veis de decis√£o:

$x_j \colon \text{quantidade a ser fabricada do produto } j \in J \text{ por semana}$

(Decis√µes que o modelo deve tomar, ou seja, quanto produzir de cada item para maximizar o lucro)

## Modelo matem√°tico:

### Fun√ß√£o Objetivo:

$\max z = \sum_{j\in J} c_j x_j$

( maximiza o lucro total obtido pela soma dos lucros individuais $c_j x_j$ )

A leitura direta seria: maximizar o lucro total $z$, que √© a soma para todos os projutos ${j\in J}$ , do lucro por unicade $c_j$ multiplicado pela quantidade produzida $x_j$

### Restri√ß√µes:

sujeito a:

#### Restri√ß√£o 1:

$\sum\limits_{j \in J} a_{ij} x_{j} \leq b_{i}, \;\; \forall \; i \in I$

Para cada recurso $i \in I$, o consumo total desse recurso (soma de $a_{ij}x_j$ sobre todos os produtos $j$ ) n√£o pode ultrapassar a disponibilidade $b_i$.

![](images/explica√ß√£o_restricao_modelo_generico_mix_produtos.png){fig-align="center"}

#### Restri√ß√£o 2:

$x_{j} \geq 0 \;\; \forall j \in J$

A quantidade prozuida de cada projuto $j$ deve ser n√£ onegativa (n√£o tem como produzir uma quantidade menor que zero). Isso vale para todo $j$ pertencente ao conjunto $J$ .

# Entrada de dados

```{python}
# vetor de lucros
c_vetor_de_lucros = [12, 60] 

# matriz A: horas por atividade para cada produto
a_matriz = [[0.25, 0.5], 
     [0.1, 0.75], 
     [0.1, 0.4]]

# vetor de disponibilidade m√°xima de horas por semana
b_vetor_de_lim_horas = [36, 22, 15]

# quantidade de itens do √≠ndice I
m_total_indices_i = len(b_vetor_de_lim_horas)

# quantidade de itens que fabrico
n_total_produtos = len(c_vetor_de_lucros)
```

# Resolu√ß√£o do problema

## 1. Importar bibliotecas

```{python}
import pyomo.environ as pyo
```

## 2. Importar e definir solver que ser√° usado

```{python}
solver = pyo.SolverFactory("glpk")
```

## 3. Declarar o modelo

```{python}
modelo = pyo.ConcreteModel()
```

## 4. Declarar √≠ndices, par√¢metros e vari√°veis de decis√£o

### 4.1 √çndices

```{python}
# 4.1 √çndices
modelo.Conj_I_Processos = range(m_total_indices_i)
modelo.Conj_J_Produtos = range(n_total_produtos)

```

### 4.2 Par√¢metros

A fun√ß√£o `initialize` do `Param` espera um **mapeamento entre √≠ndices e valores**.

Esse mapeamento pode ser criado dinamicamente (com lambda) ou explicitamente (com um dicion√°rio).

No exemplo \[op√ß√£o 3\] do par√¢metro 1 constru√≠mos primeiro o dicion√°rio `dict_c_lucro`, onde cada √≠ndice j do conjunto `Conj_J_Produtos` √© associado ao lucro c_vetor_de_lucros\[j\].

Isso deixa claro que o par√¢metro `c_lucro[j]` nada mais √© do que uma forma simb√≥lica de acessar os valores guardados no dicion√°rio `{0: 12, 1: 60}` dentro do Pyomo.

#### Par√¢metro 1: c

$c_j \colon \text{lucro liquido por unidade do produto } j \in J \text{ produzido}$

```{python}
# 4.2 Par√¢metros

# op√ß√£o 1: usando lambda
#modelo.c_lucro = pyo.Param(
#  modelo.Conj_J_Produtos, 
#  initialize = lambda modelo,  j: c_vetor_de_lucro[j]
#)

# op√ß√£o 2: criando o dicion√°rio direto no argumento initialize
#modelo.c_lucro = pyo.Param(
#  modelo.Conj_J_Produtos,
#  initialize = {j: c_vetor_de_lucros[j] for j in modelo.Conj_J_Produtos}
#)

# op√ß√£o 3: criar o dicion√°rio antes
dict_c_lucro = {j: c_vetor_de_lucros[j] for j in modelo.Conj_J_Produtos}

modelo.c_lucro = pyo.Param(
  modelo.Conj_J_Produtos,
  initialize = dict_c_lucro
)
```

#### Par√¢metro 2: a

$a_{ij} \colon \text{quantidade de horas necessarias para a execucao do processo } i \in I \text{ na fabricacao do produto } j \in J$

O par√¢metro $a_{ij}$ √© uma matriz de coeficientes que relaciona cada processo i com cada produto j.

No Pyomo, representamos essa estrutura como um dicion√°rio de pares (i, j) mapeados para seus respectivos valores.

Essa representa√ß√£o explicita a rela√ß√£o a\[i\]\[j\] ‚Üí (i, j): valor e deixa claro que o Pyomo interpreta o Param como um mapeamento entre √≠ndices e valores.

```{python}

# Monta um dicion√°rio com chaves duplas (i, j)
# representando o tempo de cada processo i para cada produto j
dict_a_matriz = {
  (i, j): a_matriz[i][j] for i in modelo.Conj_I_Processos for j in modelo.Conj_J_Produtos
}

# enxergando o dicion√°rio
print("Dicion√°rio de coeficientes a_ij:")
for chave, valor in dict_a_matriz.items():
    print(f"a{chave} = {valor}")

# estabelecendo o par√¢metro
modelo.a_matriz = pyo.Param(
  modelo.Conj_I_Processos, # √≠ndice 1 (linhas da matriz)
  modelo.Conj_J_Produtos,  # √≠ndice 2 (colunas da matriz)
  initialize = dict_a_matriz
)

```

#### Par√¢metro 3:  bi

$b_i \colon \text{quantidade de horas disponiveis para execucao do processo } i \in I$

O par√¢metro $b_i$ representa o total de horas dispon√≠veis em cada processo $i$.

Para tornar o c√≥digo mais claro, primeiro convertemos o vetor b do Python em um dicion√°rio `dict_b_horas_limite`, onde cada √≠ndice i √© mapeado ao seu valor correspondente `b[i]`.

Em seguida, passamos esse dicion√°rio para o Pyomo com o argumento `initialize`.

O Pyomo ent√£o interpreta esse mapeamento e cria o par√¢metro simb√≥lico `b[i]` dentro do modelo.

```{python}

# criar um dicion√°rio que associada cada processo i √† sua disponibilidade b[i]
dict_b_horas_limite = {i: b_vetor_de_lim_horas[i] for i in modelo.Conj_I_Processos}

# estabelecendo o par√¢metro
modelo.b_horas_limite = pyo.Param(
  modelo.Conj_I_Processos, # est√° associado ao √≠ndice i (bi)
  initialize = dict_b_horas_limite
)

```

Visualizando cada par√¢metro:

```{python}
# checando a sa√≠da dos par√¢metros:

# par√¢metro c_lucro:
print("\n" + "="*40) # printa '=' 40 vezes e faz uma qubera de linha
for j in modelo.Conj_J_Produtos:
    print(f"Produto {j}: lucro = R$ {modelo.c_lucro[j]}")

# par√¢metro a_matriz:
print("\n" + "="*40)
for i in modelo.Conj_I_Processos:
    for j in modelo.Conj_J_Produtos:
        print(f"Processo {i}, Produto {j}: a_ij = {modelo.a_matriz[i, j]} horas")

# par√¢metro b_horas_limite:
print("\n" + "="*40)
for b in modelo.Conj_I_Processos:
  print(f"Processo {b}: Disponibilidade total: {modelo.b_horas_limite[b]} horas")
```

### 4.3 Vari√°veis de decis√£o

$x_j \colon \text{quantidade a ser fabricada do produto } j \in J \text{ por semana}$

```{python}
modelo.x_variaveis = pyo.Var(
  modelo.Conj_J_Produtos,  # as vari√°veis est√£o associadas ao √≠ndice J
  within = pyo.NonNegativeReals
)


```

## 5. Declarar Fun√ß√£o Objetivo

$\max z = \sum_{j\in J} c_j x_j$

```{python}

# vers√£o compacta
#def regra_z(modelo_alvo):
#  return pyo.summation(modelo_alvo.c_lucro, modelo_alvo.x_variaveis)

# vers√£o did√°tica
def regra_z(modelo_alvo):
    # Calcula o lucro total como a soma de (lucro unit√°rio √ó quantidade produzida)
    lucro_total = sum(
        modelo_alvo.c_lucro[j] * modelo_alvo.x_variaveis[j]
        for j in modelo_alvo.Conj_J_Produtos
    )
    
    # Opcional: imprimir para conferir os termos da fun√ß√£o objetivo
    for j in modelo_alvo.Conj_J_Produtos:
        print(f"Produto {j}: {modelo_alvo.c_lucro[j]} √ó {modelo_alvo.x_variaveis[j]}")

    return lucro_total
  
modelo.z = pyo.Objective(
  rule = regra_z,
  sense = pyo.maximize
)
```

## 6. Declarar restri√ß√µes

$\sum\limits_{j \in J} a_{ij} x_{j} \leq b_{i}, \;\; \forall \; i \in I$

```{python}

# vers√£o compacta
#def regra_disp_mo(mod, i):
#    return sum(mod.a[i,j] * mod.x[j] for j in mod.J) <= mod.b[i]


def regra_disp_mo(modelo_alvo, i):
    # Calcula o total de horas utilizadas no processo i
    horas_usadas = sum(modelo_alvo.a_matriz[i, j] * modelo_alvo.x_variaveis[j] for j in modelo_alvo.Conj_J_Produtos)
    
    # Opcional: imprimir os termos da restri√ß√£o
    print(f"\nüîπ Restri√ß√£o do processo {i}:")
    for j in modelo_alvo.Conj_J_Produtos:
        print(f"  a_matriz[{i},{j}] * x_variaveis[{j}] = {modelo_alvo.a_matriz[i,j]} * x{j}")
    
    # Retorna a restri√ß√£o simb√≥lica: soma das horas usadas <= limite de horas
    return horas_usadas <= modelo_alvo.b_horas_limite[i]


modelo.restri_disp = pyo.Constraint(
  modelo.Conj_I_Processos,
  rule = regra_disp_mo
)

```

## 7. Resolver modelo

Antes de resolver, o modelo ser√° printado no console pela fun√ß√£o `pprint`. Nesse caso √© poss√≠vel rodar essa fun√ß√£o sem problemas porque o modelo √© muito pequeno. Caso fosse um problema real com centenas de vari√°veis e restri√ß√µes, n√£o seria fact√≠ve rodar esse c√≥digo.

```{python}
modelo.pprint()
```

Resolver o modelo:

```{python}
resultado = solver.solve(modelo)
```

Resultados brutos do modelo:

```{python}
resultado.write
```

Organizando o print com a sa√≠da do modelo:

```{python}
print("\n===== RESULTADOS DO MODELO =====")

# Status e condi√ß√£o de t√©rmino
print(f"Status da otimiza√ß√£o: {resultado.solver.status}")
print(f"Condi√ß√£o de t√©rmino: {resultado.solver.termination_condition}")

# Fun√ß√£o objetivo
print(f"Lucro m√°ximo (z) = R${pyo.value(modelo.z):.2f}")

# Vari√°veis de decis√£o
print("\nüì¶ Quantidades √≥timas a produzir:")
for j in modelo.Conj_J_Produtos:
    print(f"  Produto {j}: x[{j}] = {modelo.x_variaveis[j]():.2f} unidades")

# Restri√ß√µes
print("\n‚è±Ô∏è Verifica√ß√£o das restri√ß√µes (uso de horas):")
for i in modelo.Conj_I_Processos:
    lhs = sum(pyo.value(modelo.a_matriz[i,j]) * modelo.x_variaveis[j]() for j in modelo.Conj_J_Produtos)
    rhs = pyo.value(modelo.b_horas_limite[i])
    print(f"  Processo {i}: usado = {lhs:.2f} h | limite = {rhs:.2f} h | folga = {rhs - lhs:.2f} h")
```